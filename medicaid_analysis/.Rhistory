# Define Function
tidy_table <- function(file, measure = NULL){
cols_to_keep <- c("State", "Population", "Measure Abbreviation", "State Rate")
file <- file[, cols_to_keep]
file <- file[file$Population == "Medicaid", ]
if (!is.null(measure)){
file <- file[file$`Measure Abbreviation` == measure, ]
}
return(file)
}
# Read in files
file_2022 <- read_csv("raw_data/2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2022 <- tidy_table(file_2022)
file_2022$ffy <- "2022"
file_2021 <- read_csv("raw_data/2021_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2021 <- tidy_table(file_2021)
file_2021$ffy <- "2021"
file_2020 <- read_csv("raw_data/2020_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2020 <- tidy_table(file_2020)
file_2020$ffy <- "2020"
file_2019 <- read_csv("raw_data/2019_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2019 <- tidy_table(file_2019)
file_2019$ffy <- "2019"
file_2018 <- read_csv("raw_data/2018_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2018 <- tidy_table(file_2018)
file_2018$ffy <- "2018"
file_2017 <- read_csv("raw_data/2017_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2017 <- tidy_table(file_2017)
file_2017$ffy <- "2017"
file_2016 <- read_csv("raw_data/2016_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2016 <- tidy_table(file_2016)
file_2016$ffy <- "2016"
file_2015 <- read_csv("raw_data/2015_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2015 <- tidy_table(file_2015)
file_2015$ffy <- "2015"
file_2014 <- read_csv("raw_data/2014_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2014 <- tidy_table(file_2014)
file_2014$ffy <- "2014"
df_combined <- rbind(file_2014, file_2015, file_2016, file_2017, file_2018, file_2019,
file_2020, file_2021, file_2022)
# Rename columns
colnames(df_combined) <- c("state", "population", "state_rate", "ffy")
# Write to CSV
write.csv(df_combined, "2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv", row.names = FALSE)
View(df_combined)
########################################################################################
# Purpose: To merge Adult Healthcare Quality Measure Files together
# Author: William Pang
# Source: CMS
# https://www.medicaid.gov/medicaid/quality-of-care/performance-measurement/
# adult-and-child-health-care-quality-measures/adult-health-care-quality-measures/index.html
########################################################################################
setwd("/Users/williampang/Desktop/innovation_team_interview/innovation_team_interview/medicaid_analysis")
library(tidyverse)
# Define Function
tidy_table <- function(file, measure = NULL){
cols_to_keep <- c("State", "Population", "Measure Abbreviation", "State Rate")
file <- file[, cols_to_keep]
file <- file[file$Population == "Medicaid", ]
if (!is.null(measure)){
file <- file[file$`Measure Abbreviation` == measure, ]
}
return(file)
}
# Read in files
file_2022 <- read_csv("raw_data/2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2022 <- tidy_table(file_2022)
file_2022$ffy <- "2022"
file_2021 <- read_csv("raw_data/2021_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2021 <- tidy_table(file_2021)
file_2021$ffy <- "2021"
file_2020 <- read_csv("raw_data/2020_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2020 <- tidy_table(file_2020)
file_2020$ffy <- "2020"
file_2019 <- read_csv("raw_data/2019_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2019 <- tidy_table(file_2019)
file_2019$ffy <- "2019"
file_2018 <- read_csv("raw_data/2018_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2018 <- tidy_table(file_2018)
file_2018$ffy <- "2018"
file_2017 <- read_csv("raw_data/2017_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2017 <- tidy_table(file_2017)
file_2017$ffy <- "2017"
file_2016 <- read_csv("raw_data/2016_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2016 <- tidy_table(file_2016)
file_2016$ffy <- "2016"
file_2015 <- read_csv("raw_data/2015_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2015 <- tidy_table(file_2015)
file_2015$ffy <- "2015"
file_2014 <- read_csv("raw_data/2014_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
file_2014 <- tidy_table(file_2014)
file_2014$ffy <- "2014"
df_combined <- rbind(file_2014, file_2015, file_2016, file_2017, file_2018, file_2019,
file_2020, file_2021, file_2022)
# Rename columns
colnames(df_combined) <- c("state", "population", "measure_abbreviation",
"state_rate", "ffy")
# Write to CSV
write.csv(df_combined, "2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv", row.names = FALSE)
View(df_combined)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(-coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(-store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
View(store)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(-coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(-store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
View(coefficients)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(-store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
View(coefficients)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(-store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
View(store)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
# Load libraries
library(tidyverse)
library(broom)
# Set Working Directory
setwd("/Users/williampang/Desktop/innovation_team_interview/medicaid_analysis")
###### Define Measures to Run ####
measure_names <- c("BCS-AD", "CCS-AD", "PPC-AD", "CHL-AD")
##################################
# Grab quality_measures dataset
quality_measures <- read_csv("2014_to_2022_Child_and_Adult_Health_Care_Quality_Measures_Quality.csv")
# Remove state rates with weird coding
quality_measures <- quality_measures[quality_measures$state_rate != "NR", ]
quality_measures <- quality_measures[quality_measures$state_rate != "DS", ]
iteration = 1
store <- data.frame()
for (measure in measure_names){
quality_measures_subset <- quality_measures[quality_measures$measure_abbreviation == measure, ]
###
# QA: Check to make sure each state only has one unique year
qaDistinctYear <- quality_measures_subset %>%
group_by(state) %>%
summarize(unique_years = n_distinct(ffy),
row_count = n())
different_rows <- qaDistinctYear %>% filter(unique_years != row_count)
if (nrow(different_rows) == 0) {
print("No rows with duplicate years.")
}
else{
stop("Detected rows with duplicate years")
}
###
models <- quality_measures_subset %>%
group_by(state) %>%
do(model = lm(state_rate ~ reporting_date + postcovid + reporting_date * postcovid, data = .))
# Extract coefficients from the models
coefficients <- models %>%
summarise(state = first(state),
beta1 = coef(model)[2],
beta3 = ifelse(length(coef(model)) > 3, coef(model)[4], NA))
# Remove rows with nulls and rank
coefficients <- coefficients[!is.na(coefficients$beta3), ]
coefficients$beta3rank <- rank(coefficients$beta3)
# Rename
beta1 <- paste0(measure, "_beta1")
beta3 <- paste0(measure, "_beta3")
beta3rank <- paste0(measure, "_beta3rank")
colnames(coefficients) <- c("state", beta1, beta3, beta3rank)
if (iteration == 1){
store <- coefficients
}
else {
store <- full_join(store, coefficients, by = "state")
}
# Increment
iteration = iteration + 1
}
# Average
beta3_rank_measure_names <- paste0(measure_names, "_beta3rank")
store$mean_rank <- rowMeans(store[beta3_rank_measure_names], na.rm = TRUE)
# Remove states with more than 1 measure being NA
na_count <- data.frame(store$state, cnt = rowSums(is.na(store)))
na_count <- na_count %>% filter(cnt > 3)
states_to_remove <- na_count$store.state
store <- store %>%
filter(!state %in% states_to_remove)
# Rank average of ranks
store$final_ranking <- rank(store$mean_rank)
write.csv(store, "quality_measures_prepostcovid_rank.csv", row.names = FALSE)
